const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

const targetHosts = {
  'example.com': { host: 'TARGET HOST IP', port: 80 },
};

if (cluster.isMaster) {
  console.log(`${process.pid}`);

  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  const http = require('http');
  const rateLimitReq = 10;
  const rateLimitTim = 1000;
  const maxPacketSize = 10000;
  const maxUserAgentRequests = 10;

  const xssPattern = /<script\b[^>]*>([\s\S]*?)<\/script>/gi;

  const ipRequests = new Map();
  const userAgentRequests = new Map();

  const server = http.createServer((req, res) => {
    const ipAddress = req.socket.remoteAddress;
    const userAgent = req.headers['user-agent'];

    const ipRequestsList = ipRequests.get(ipAddress) || [];
    const now = Date.now();
    ipRequestsList.push(now);
    ipRequests.set(ipAddress, ipRequestsList);

    const recentIpRequests = ipRequestsList.filter(requestTime => requestTime > now - rateLimitTim);
    if (recentIpRequests.length > rateLimitReq) {
      res.statusCode = 404;
      res.end();
      return;
    }

    const userAgentRequestsList = userAgentRequests.get(userAgent) || [];
    userAgentRequestsList.push(now);
    userAgentRequests.set(userAgent, userAgentRequestsList);

    const recentUserAgentRequests = userAgentRequestsList.filter(requestTime => requestTime > now - rateLimitTim);
    if (recentUserAgentRequests.length > maxUserAgentRequests) {
      res.statusCode = 404;
      res.end();
      return;
    }

    const target = targetHosts[req.headers.host];
    if (target) {
      if (req.method === 'POST') {
        checkXSS(req, (err) => {
          if (err) {
            res.statusCode = 404;
            res.end();
          } else {
            next(req, res, target.host, target.port);
          }
        });
      } else {
        next(req, res, target.host, target.port);
      }
    } else {
      res.statusCode = 404;
      res.end();
    }
  });

  function next(req, res, targetHost, targetPort) {
    const contentLength = parseInt(req.headers['content-length']);
    if (contentLength > maxPacketSize) {
      res.statusCode = 413;
      res.end();
      return;
    }

    const options = {
      host: targetHost,
      port: targetPort,
      path: req.url,
      method: req.method,
      headers: req.headers
    };
    const proxyReq = http.request(options, (proxyRes) => {
      res.writeHead(proxyRes.statusCode, proxyRes.headers);
      proxyRes.pipe(res);
    });

    proxyReq.on('error', (err) => {
      console.error(`Error: host offline`);
      res.statusCode = 404;
      res.end();
    });

    req.pipe(proxyReq);
  }

  function checkXSS(req, callback) {
    let body = '';
    req.on('data', (chunk) => {
      body += chunk;
    });
    req.on('end', () => {
      if (xssPattern.test(body)) {
        callback('XSS detected');
      } else {
        callback();
      }
    });
  }

server.listen(80, () => {
  console.log('Proxy server listening on port 80');
});

}
